This page is merely an excerpt from [my scratchpad](http://code.google.com/p/truesight/source/browse/#svn/trunk/Scratchpad/Truesight), but the latter is stored in an uncommon format (OneNote) and is written mostly in Russian, so for the majority of potential readers who will be scared away by these peculiarities I provide a summary of my design activities here.

`***`

Library is split into three namespaces that extensively cover activities related to reflection and code generation for the .NET platform. The first two namespaces expose two different views of the program - meta and code (one can work with code using either low-level or high-level model or mix them). The third namespace provides facilities that can be used to dynamically inspect objects, modify them (applicable only to dynamics), and perform late-bound member accesses and calls.

Basic design guidelines:
  * Consistent, strongly-typed and fluent API.
  * One of the most important design imperatives is YAGNI. For example, never in my life I needed to work with multi-module assemblies, reflecting on p/invoke imports or event infos. So the first version includes only thingies that I found to be widely used in my personal projects. Surely, I will append the functionality when it becomes necessary, but not before.
  * All collections (i.e. methods of a type, assemblies of an appdomain and so on) are exposed as enumerables (i.e. no more GetXXX overloads => every query you wish you're free to express with LINQ). Those collections also expose read-only indexers (that encapsulate the most common queries) and factory methods that create and add new entities. Add/Update/Remove operations are a part of a big picture of implementing a custom interface - IUpdatable (just like querying is a part of a big picture of implementing IEnumerable and leveraging extension methods defined in System.Linq.Enumerable).
  * No compatibility with stock Reflection and Reflection.Emit APIs - only extension methods that seamlessly integrate them with Truesight's object model. This is done on purpose to ensure that old-style abstractions and APIs don't leak into Truesight.

Meta object model:
  * Meta model sacrifices completeness for the sake of simplicity. Truesight provides: appdomains that contain asms, asms that contain resources, dynamic methods and classes/interfaces, classes/interfaces that contain fields, properties, methods, and, finally, methods also feature params (this includes retval as well). Any of those except appdomains and resources can also be annotated by attributes. Things can be generic - this is a whole new level of complexity, so Truesight respects that and provides both simple and complicated but powerful approaches to deal with it. That's all.
  * Changing meta model doesn't impose any restrictions in addition to natural restrictions of CLR (i.e. no changes to code that is just created or already loaded for execution) - e.g. 1) introducing a new type is as easy as calling an Add method of the Types collection of an assembly, 2) enumerating assembly types or class' members works the same way regardless of whether they're being edited or not, 3) persisting dynamic methods needs just calling Add method of the  Methods collection of an auxiliary class, loading them back needs just calling Add method of the DynamicMethods collection of an appdomain - as simple as that.

Code object model:
  * Code model is represented by two orthogonal views - low-level (IL-based) and high-level (represented by expression trees of .NET 4). Low-level API provides comprehensive support of CLR infrastructure, while high-level approach (which is essentially based on decompilation) enables certain powerful techniques such as "code as data" and metaprogramming.
  * Generating new code also comes in two flavors - low-level one implements read-write random access to IL (this extends Reflection.Emit that's limited to write-only sequential access), high-level one gives a way to emit code using statically written lambdas in high-level language (e.g. C#) and provides several tricks that integrate such lambdas with fragments that need to be generated dynamically.

Late-bound and dynamic facilities:
  * Truesight defines abstractions of a slot (i.e. field or property) and a callsite (i.e. regular or dynamic method). These thingies can be either typed/untyped or bound/unbound (4 options total). There are two ways to get them - via "this Object target" extension methods or via casting corresponding meta model objects.
  * With the aid of slots and callsites one can perform late-bound member accesses and invocations in one of two flavors: in-place and detached. In-place flavor is similar to dynamic features in C# 4.0, is not as concise, but doesn't require your object to be cast to "dynamic" in advance. Detached flavor provides one a functor object that can be passed around within an appdomain, be strongly typed with casts, and bound/unbound to/from targets.
  * The facilities in subject support three different kinds of managed objects - regular objects that are instances of regular managed classes, dynamic objects that implement IDynamicMetaObjectProvider interface from .NET 4, and runtime callable proxies of COM objects.